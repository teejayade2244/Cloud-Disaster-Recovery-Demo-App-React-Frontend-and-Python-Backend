name: Backend CI/CD Pipeline
on:
  push:
    branches:
      - master
    paths:
      - 'Backend-app/**'
      - '.github/workflows/backend-ci-cd.yml'
  pull_request:
    branches:
      - "*"
    paths:
      - 'Backend-app/**'
      - '.github/workflows/backend-ci-cd.yml'

# Permissions required for OIDC authentication and checking out code
permissions:
  id-token: write
  contents: read

jobs:
  build-and-push:
    runs-on: self-hosted

    steps:
      - name: Checkout repository code
        uses: actions/checkout@v4

      - name: Checkout Kubernetes Manifests repository
        uses: actions/checkout@v4
        with:
          repository: teejayade2244/AWS-Cloud-Disaster-Recovery-Manifest-Repo
          ref: master
          token: ${{ secrets.REPO_PAT }}
          path: AWS-Cloud-Disaster-Recovery-Manifest-Repo

      # --- Configure AWS Credentials using OIDC (for eu-west-2 by default) ---
      # This initial configuration assumes the primary cluster and ECR are in eu-west-2
      - name: Configure AWS Credentials (eu-west-2)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_GITHUB_ACTIONS_ROLE_ARN }}
          aws-region: eu-west-2 # Primary region

      # --- Install Python dependencies for scanning (for fs scan if needed) ---
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install Backend Python Dependencies
        working-directory: ./Backend-app
        run: pip install -r requirements.txt

      # --- Scan Dependencies for Vulnerabilities (using Trivy FS Scan) ---
      - name: Run Trivy FS Scan for Dependencies
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          input: './Backend-app'
          format: 'table'
          severity: 'HIGH,CRITICAL'
          exit-code: 1

      # --- Docker Build (happens only once) ---
      - name: Build Backend Docker Image
        working-directory: ./Backend-app
        env:
          ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY_NAME }} # This is just for naming the local image
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t ${{ vars.ECR_REPOSITORY_NAME }}:$IMAGE_TAG .

      # --- Login and Push to Primary ECR (eu-west-2) ---
      - name: Login to Amazon ECR (eu-west-2)
        id: login-ecr-primary
        uses: aws-actions/amazon-ecr-login@v2
        with:
          aws-region: eu-west-2

      - name: Push Backend Docker Image to Primary ECR (eu-west-2)
        working-directory: ./Backend-app
        env:
          ECR_REGISTRY: ${{ steps.login-ecr-primary.outputs.registry }}
          ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY_NAME }} 
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker tag ${{ vars.ECR_REPOSITORY_NAME }}:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

      - name: Get Primary ECR Image URI
        id: ecr_image_uri_primary
        run: |
          ECR_URI="${{ steps.login-ecr-primary.outputs.registry }}/${{ vars.ECR_REPOSITORY_NAME }}:${{ github.sha }}"
          echo "ECR_IMAGE_URI_PRIMARY=$ECR_URI" >> $GITHUB_OUTPUT

      # --- Login and Push to DR ECR (us-east-1) ---
      - name: Configure AWS Credentials (us-east-1) for DR ECR
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_GITHUB_ACTIONS_ROLE_ARN }} 
          aws-region: us-east-1

      - name: Login to Amazon ECR (us-east-1)
        id: login-ecr-dr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          aws-region: us-east-1

      - name: Push Backend Docker Image to DR ECR (us-east-1)
        working-directory: ./Backend-app
        env:
          ECR_REGISTRY: ${{ steps.login-ecr-dr.outputs.registry }}
          ECR_REPOSITORY: ${{ vars.DR_ECR_REPOSITORY_NAME }} 
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker tag ${{ vars.ECR_REPOSITORY_NAME }}:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

      - name: Get DR ECR Image URI
        id: ecr_image_uri_dr
        run: |
          ECR_URI="${{ steps.login-ecr-dr.outputs.registry }}/${{ vars.DR_ECR_REPOSITORY_NAME }}:${{ github.sha }}"
          echo "ECR_IMAGE_URI_DR=$ECR_URI" >> $GITHUB_OUTPUT

      # --- Deploy to Primary EKS Cluster (eu-west-2) ---
      - name: Configure AWS Credentials (eu-west-2) for Primary EKS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_GITHUB_ACTIONS_ROLE_ARN }}
          aws-region: eu-west-2

      - name: Update Manifest for Primary Cluster and Deploy
        run: |
          MANIFEST_FILE="AWS-Cloud-Disaster-Recovery-Manifest-Repo/kubernetes/backend.yaml"
          NEW_IMAGE_URI="${{ steps.ecr_image_uri_primary.outputs.ECR_IMAGE_URI_PRIMARY }}"
          echo "Updating manifest ($MANIFEST_FILE) for Primary Cluster with image: $NEW_IMAGE_URI"
          sed -i "/image:/c\        image: ${NEW_IMAGE_URI}" "$MANIFEST_FILE"
          cat "$MANIFEST_FILE" # Optional: Print for debugging

          echo "Deploying to Primary EKS Cluster (${{ vars.EKS_CLUSTER_NAME }})"
          kubectl apply -f "$MANIFEST_FILE"

      # --- Deploy to DR EKS Cluster (us-east-1) ---
      - name: Configure AWS Credentials (us-east-1) for DR EKS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_GITHUB_ACTIONS_ROLE_ARN }}
          aws-region: us-east-1

      - name: Setup kubectl for DR Cluster
        uses: aws-actions/amazon-eks-setup@v2
        with:
          cluster-name: ${{ vars.DR_EKS_CLUSTER_NAME }} # DR EKS cluster name
          aws-region: us-east-1

      - name: Update Manifest for DR Cluster and Deploy
        run: |
          MANIFEST_FILE="AWS-Cloud-Disaster-Recovery-Manifest-Repo/kubernetes/backend.yaml"
          NEW_IMAGE_URI="${{ steps.ecr_image_uri_dr.outputs.ECR_IMAGE_URI_DR }}"
          echo "Updating manifest ($MANIFEST_FILE) for DR Cluster with image: $NEW_IMAGE_URI"
          # Use sed to replace the entire image line
          sed -i "/image:/c\        image: ${NEW_IMAGE_URI}" "$MANIFEST_FILE"
          cat "$MANIFEST_FILE" # Optional: Print for debugging

          echo "Deploying to DR EKS Cluster (${{ vars.DR_EKS_CLUSTER_NAME }})"
          kubectl apply -f "$MANIFEST_FILE"
